<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Timeline Map</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/vis-timeline@latest/dist/vis-timeline-graph2d.min.css" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #000;
      color: #fff;
      font-family: sans-serif;
    }

    #timeline-container {
      position: relative;
      height: 35vh;
      border-bottom: 2px solid #fff;
      box-sizing: border-box; /* Ensures padding/border don't add to height */
    }

    #timeline {
      height: 100%;
    }

    #indicator {
      position: absolute;
      top: 0;
      bottom: 0;
      left: 50%;
      width: 2px;
      margin-left: -1px; /* To center the 2px line */
      background: red;
      z-index: 10; /* Above timeline items but below popups if any */
      pointer-events: none; /* So it doesn't interfere with timeline interactions */
    }

    #indicator::after { /* This creates the triangle/arrow */
      content: '';
      position: absolute;
      bottom: -6px; /* Position below the line */
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 6px solid transparent;
      border-right: 6px solid transparent;
      border-top: 6px solid red; /* Points downwards */
    }

    #year-label {
      position: absolute;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7);
      color: #fff;
      padding: 3px 8px;
      font-size: 14px;
      border-radius: 3px;
      pointer-events: none;
      z-index: 11;
    }

    #map {
      height: 65vh;
    }

    .event-label {
      background: rgba(0, 0, 0, 0.7);
      color: #fff;
      padding: 2px 4px;
      border-radius: 3px;
      font-size: 12px;
      font-weight: bold;
      text-shadow: 0 0 3px #000;
    }

    /* Vis.js Timeline Item Styling */
    .vis-item {
      color: #000; /* Text color inside items */
      background-color: #ffc107; /* A yellow shade, good contrast on dark */
      border-color: #e0a800; /* Darker border for items */
    }
    .vis-item.vis-selected {
      background-color: #ffa000;
      border-color: #c67c00;
    }

    /* Vis.js Timeline general styling (if needed for dark theme) */
    .vis-timeline {
      border: 1px solid #444;
    }
    .vis-time-axis .vis-grid.vis-major {
      border-color: #555;
    }
    .vis-time-axis .vis-grid.vis-minor {
      border-color: #333;
    }
    .vis-time-axis .vis-text {
      color: #ccc;
    }
    .vis-item .vis-item-content {
        padding: 5px;
    }
  </style>
</head>
<body>
  <div id="timeline-container">
    <div id="timeline"></div>
    <div id="indicator"></div>
    <div id="year-label">Loading...</div>
  </div>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-polylinedecorator@1.7.0/dist/leaflet.polylineDecorator.min.js"></script>
  <script src="https://unpkg.com/vis-timeline@7.7.0/dist/vis-timeline-graph2d.min.js"></script>

  <script>
    // --- START OF data.js ---
    const events = [
      {
        id: 1,
        content: 'Event 1 (Rome)',
        start: '2024-01-01',
        end: '2024-01-02',
        latlng: [41.9, 12.5],
        popup: 'Rome Event (Jan 1-2, 2024)'
      },
      {
        id: 2,
        content: 'Event 2 (Paris)',
        start: '2024-02-01',
        end: '2024-02-02',
        latlng: [48.8, 2.3],
        popup: 'Paris Event (Feb 1-2, 2024)'
      },
      {
        id: 3,
        content: 'Event 3 (London)',
        start: '2024-03-01',
        end: '2024-03-02',
        latlng: [51.5, -0.1],
        popup: 'London Event (Mar 1-2, 2024)'
      },
      { // Example of an event with a longer duration for testing timeline range
        id: 4,
        content: 'Long Event',
        start: '2023-12-01',
        end: '2024-04-30',
        latlng: [40.7128, -74.0060], // New York
        popup: 'Long Event spanning multiple months'
      },
      {
        id: 5,
        content: 'Ancient Festival (Athens)',
        start: '2022-06-01',
        end: '2022-06-02',
        latlng: [37.98, 23.72],
        popup: 'Athens Festival (Jun 1-2, 2022)'
      },
      {
        id: 6,
        content: 'Dorian origin (Northern Greece)',
        start: '-1200-01-01',
        end: '-1200-01-02',
        latlng: [40.5, 22.0],
        popup: 'Dorians located in Thessaly/Macedonia (~1200 BC)'
      },
      {
        id: 7,
        content: 'Dorians move toward Pindus',
        start: '-1100-01-01',
        end: '-1100-01-02',
        latlng: [39.3, 21.0],
        popup: 'Migration south to the Pindus range (~1100 BC)'
      },
      {
        id: 8,
        content: 'Dorians enter Peloponneso',
        start: '-1000-01-01',
        end: '-1000-01-02',
        latlng: [37.5, 22.0],
        popup: 'Arrival of Dorians in Peloponnesus (~1000 BC)'
      }
      ];
    // --- END OF data.js ---
  </script>

  <script>
    // --- START OF empires.js ---
    const empires = [
      {
        name: 'Imperium Italicum',
        segments: [
          {
            start: '2024-01-01',
            end: '2024-01-15',
            coordinates: [ // Smaller Italy
              [
                [44.0, 7.5],  // NW
                [46.5, 13.5], // NE
                [40.0, 18.0], // SE
                [38.0, 12.0], // SW
                [41.0, 9.0]   // W
              ]
            ]
          },
          {
            start: '2024-01-16',
            end: '2024-01-31',
            coordinates: [ // Larger Italy, expanded
              [
                [46, 7],      // Further NW
                [47, 14],     // Further NE
                [39, 19],     // Further SE
                [37, 11],     // Further SW
                [40, 8]       // Further W
              ]
            ]
          }
        ],
        style: { color: '#ff0000', weight: 2, fillColor: '#ff0000', fillOpacity: 0.3 }
      },
      {
        name: 'Regnum Francorum',
        segments: [
          {
            start: '2024-02-01',
            end: '2024-02-14',
            coordinates: [ // Smaller France
              [
                [50, -2],
                [50, 4],
                [45, 4],
                [45, -2]
              ]
            ]
          },
          {
            start: '2024-02-15',
            end: '2024-02-29', // Note: 2024 is a leap year
            coordinates: [ // Larger France
              [
                [51, -5], // NW
                [51, 7],  // NE
                [43, 7],  // SE
                [43, -5]  // SW
              ]
            ]
          }
        ],
        style: { color: '#0000ff', weight: 2, fillColor: '#0000ff', fillOpacity: 0.3 }
      },
      {
        name: 'Britannia',
        segments: [
          {
            start: '2024-03-01',
            end: '2024-03-31',
            coordinates: [
              [
                [58, -7], // Scotland North
                [58, 2],  // East coast
                [50, 2],  // SE England
                [50, -7]  // SW England/Wales
              ]
            ]
          }
        ],
        style: { color: '#00ff00', weight: 2, fillColor: '#00ff00', fillOpacity: 0.3 }
      },
      { // Example of an empire that appears much earlier to test timeline range
        name: 'Ancient Empire',
        segments: [
            {
                start: '2023-01-01',
                end: '2023-06-30',
                coordinates: [
                    [
                        [35, 30], [35, 40], [30, 40], [30, 30] // A fictional area
                    ]
                ]
            }
        ],
        style: { color: '#ffff00', weight: 2, fillColor: '#ffff00', fillOpacity: 0.2 }
      },
      {
        name: 'Classical Empire',
        segments: [
          {
            start: '2022-01-01',
            end: '2022-12-31',
            coordinates: [
              [
                [20, 20], [20, 30], [10, 30], [10, 20]
              ]
            ]
          }
        ],
        style: { color: '#00ffff', weight: 2, fillColor: '#00ffff', fillOpacity: 0.2 }
      }
      ];
    // --- END OF empires.js ---
  </script>

  <script>
    // --- START OF objects.js ---
    const objects = [
      {
        start: '2024-01-05',
        end: '2024-01-20',
        type: 'marker',
        latlng: [40.5, 11], // Slightly SE of Rome
        popup: 'Sample Marker (Jan 5-20)'
        // No style property here, will use default Leaflet marker
      },
      {
        start: '2024-02-10',
        end: '2024-02-25',
        type: 'polyline',
        coordinates: [
          [48, 0],  // West of Paris
          [49, 2.5], // North of Paris
          [48, 5]   // East of Paris
        ],
        style: { color: '#ff8800', weight: 3 },
        popup: 'Trade Route (Feb 10-25)',
        decorated: true
      },
      {
        start: '2024-03-10',
        end: '2024-03-20',
        type: 'polygon',
        coordinates: [
          [ // A region in southern Britain
            [51.0, -3.0],
            [51.5, -1.0],
            [50.5, -1.0],
            [50.0, -3.0]
          ]
        ],
        style: { color: '#8800ff', weight: 2, fillColor: '#8800ff', fillOpacity: 0.4 },
        popup: 'Special Region (Mar 10-20)'
      },
      { // Example of an object for the much earlier empire
        start: '2023-03-01',
        end: '2023-05-31',
        type: 'marker',
        latlng: [32.5, 35], // In the "Ancient Empire" area
        popup: 'Ancient Site (Mar-May 2023)'
      },
      {
        start: '2022-04-01',
        end: '2022-04-15',
        type: 'marker',
        latlng: [25, 25],
        popup: 'Classical Ruins (Apr 1-15, 2022)'
      },
      {
        start: '-1200-01-01',
        end: '-1000-01-01',
        type: 'polyline',
        coordinates: [
          [40.5, 22.0], // Thessaly/Macedonia
          [39.3, 21.0], // Pindus region
          [37.5, 22.0]  // Peloponneso
        ],
        style: { color: '#00ffff', weight: 2 },
        popup: 'Dorian migration path (~1200-1000 BC)',
        decorated: true
      },
      {
        start: '-1000-01-01',
        end: '-1000-01-02',
        type: 'marker',
        latlng: [37.07, 22.43],
        popup: 'Sparta settled by Dorians'
      },
      {
        start: '-1000-01-01',
        end: '-1000-01-02',
        type: 'marker',
        latlng: [37.94, 22.93],
        popup: 'Corinth as a Dorian center'
      }
      ];
    // --- END OF objects.js ---
  </script>

  <script>
    // --- START OF main.js (corrected and enhanced) ---
      // Initialize map
      const map = L.map('map').setView([45, 5], 4); // Wider initial view
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: 'Â© OpenStreetMap contributors'
      }).addTo(map);

      function parseDate(str) {
        if (typeof str === 'string' && str.startsWith('-')) {
          const parts = str.slice(1).split('-');
          const year = -Number(parts[0]);
          const month = Number(parts[1] || 1);
          const day = Number(parts[2] || 1);
          return new Date(year, month - 1, day);
        }
        return new Date(str);
      }

      // Add event markers and store references
      const eventMarkers = {};
      for (const evt of events) {
        const marker = L.marker(evt.latlng)
          .bindPopup(evt.popup);
        marker.bindTooltip(evt.content, {
          permanent: true,
          direction: 'top',
          className: 'event-label'
        });
        eventMarkers[evt.id] = marker;
        marker.on('click', () => {
          if (timeline) {
            timeline.setSelection(evt.id, { focus: true });
          }
        });
      }

      // Prepare empire layers
      const empireLayers = {};
      for (const emp of empires) {
        // Initial coordinates are not strictly necessary as they'll be set by updateEmpires
        // But providing first segment's coordinates can prevent an error if update is delayed.
        const firstSeg = emp.segments.length > 0 ? emp.segments[0] : { coordinates: [] };
        const layer = L.polygon(firstSeg.coordinates, emp.style).bindPopup(emp.name);
        empireLayers[emp.name] = { layer, currentSegment: null };
      }

      // Prepare additional object layers
      const objectLayers = [];
      for (const obj of objects) {
        let layer;
        let decorator;
        if (obj.type === 'marker') {
          layer = L.marker(obj.latlng, obj.style || {});
        } else if (obj.type === 'polyline') {
          layer = L.polyline(obj.coordinates, obj.style);
          if (obj.decorated) {
            decorator = L.polylineDecorator(layer, {
              patterns: [
                {
                  offset: '5%',
                  repeat: '10%',
                  symbol: L.Symbol.arrowHead({
                    pixelSize: 8,
                    polygon: false,
                    pathOptions: { stroke: true, color: layer.options.color || '#000' }
                  })
                }
              ]
            });
          }
        } else if (obj.type === 'polygon') {
          layer = L.polygon(obj.coordinates, obj.style);
        }
        if (layer && obj.popup) {
          layer.bindPopup(obj.popup);
        }
        if (layer) {
          const entry = { obj, layer };
          if (decorator) {
            entry.decorator = decorator;
          }
          objectLayers.push(entry);
        }
      }

      // Calculate global time range
      let minTimelineEdge = new Date('9999-12-31').getTime();
      let maxTimelineEdge = new Date('0000-01-01').getTime();

      function updateOverallTimeRange(startTimeStr, endTimeStr) {
        if (startTimeStr) {
          const startTime = parseDate(startTimeStr).getTime();
          if (!isNaN(startTime) && startTime < minTimelineEdge) {
            minTimelineEdge = startTime;
          }
        }
        if (endTimeStr) {
          const endTime = parseDate(endTimeStr).getTime();
          if (!isNaN(endTime) && endTime > maxTimelineEdge) {
            maxTimelineEdge = endTime;
          }
        }
      }

      events.forEach(evt => updateOverallTimeRange(evt.start, evt.end));
      empires.forEach(emp => emp.segments.forEach(seg => updateOverallTimeRange(seg.start, seg.end)));
      objects.forEach(obj => updateOverallTimeRange(obj.start, obj.end));
      
      if (minTimelineEdge > maxTimelineEdge) { // Fallback if no valid dates
          const now = new Date();
          minTimelineEdge = new Date(now.getFullYear(), 0, 1).getTime(); // Jan 1st of current year
          maxTimelineEdge = new Date(now.getFullYear(), 11, 31).getTime(); // Dec 31st of current year
          if (minTimelineEdge > maxTimelineEdge) { // Should not happen with current logic
            minTimelineEdge = new Date(2000,0,1).getTime();
            maxTimelineEdge = new Date(2000,11,31).getTime();
          }
      }
      
      const timelineMin = new Date(minTimelineEdge);
      const timelineMax = new Date(maxTimelineEdge);

      // Initialize timeline
      const timelineEl = document.getElementById('timeline');
      const yearLabel = document.getElementById('year-label');

      const timelineItems = new vis.DataSet(events);
      const timelineOptions = {
        height: '100%',
        start: timelineMin,
        end: new Date(Math.max(timelineMin.getTime() + (30 * 24 * 60 * 60 * 1000), timelineMax.getTime())), // Ensure at least a 30-day window or full range
        // Allow zooming in to one day and out to roughly the limits of the
        // JavaScript Date range (~275k years)
        zoomMin: 1000 * 60 * 60 * 24, // Minimum zoom level: 1 day
        zoomMax: 8640000000000000 // Max zoom level: about 275k years
      };
      
      if (timelineOptions.end.getTime() <= timelineOptions.start.getTime()) {
        timelineOptions.end = new Date(timelineOptions.start.getTime() + 30 * 24 * 60 * 60 * 1000); // Add 30 days
      }


      const timeline = new vis.Timeline(timelineEl, timelineItems, timelineOptions);

      function updateIndicator() {
        if (!timeline) return;
        const windowRange = timeline.getWindow();
        if (windowRange.start && windowRange.end) {
            const centerTime = (windowRange.start.getTime() + windowRange.end.getTime()) / 2;
            const centerDate = new Date(centerTime);
            yearLabel.textContent = centerDate.toLocaleDateString(undefined, { year: 'numeric', month: 'short' });
        } else {
            yearLabel.textContent = "N/A";
        }
      }

      timeline.on('select', props => {
        const id = props.items[0];
        if (id && eventMarkers[id]) {
          const marker = eventMarkers[id];
          map.setView(marker.getLatLng(), 8); // Zoom level 8 when selecting an event
          marker.openPopup();
        }
      });
      
      function updateMapLayers() {
        if (!timeline) return;
        const range = timeline.getWindow();
        if (!range.start || !range.end) return; // Timeline not ready

        const viewStart = range.start;
        const viewEnd = range.end;

        // Update Empires
        for (const emp of empires) {
          const info = empireLayers[emp.name];
          if (!info) continue;
          const layer = info.layer;
          let activeSegment = null;
          for (const s of emp.segments) {
            const segStart = parseDate(s.start);
            const segEnd = parseDate(s.end);
            // Check for overlap: (SegStart <= ViewEnd) and (SegEnd >= ViewStart)
            if (segStart <= viewEnd && segEnd >= viewStart) {
              activeSegment = s;
              break; 
            }
          }

          if (activeSegment) {
            if (info.currentSegment !== activeSegment) {
              layer.setLatLngs(activeSegment.coordinates);
              info.currentSegment = activeSegment;
            }
            if (!map.hasLayer(layer)) {
              layer.addTo(map);
            }
          } else if (map.hasLayer(layer)) {
            map.removeLayer(layer);
            info.currentSegment = null;
          }
        }

        // Update Objects
        for (const item of objectLayers) {
          const obj = item.obj;
          const layer = item.layer;
          const decorator = item.decorator;
          const objStart = parseDate(obj.start);
          const objEnd = parseDate(obj.end);
          // Check for overlap: (ObjStart <= ViewEnd) and (ObjEnd >= ViewStart)
          if (objStart <= viewEnd && objEnd >= viewStart) {
            if (!map.hasLayer(layer)) {
              layer.addTo(map);
            }
            if (decorator && !map.hasLayer(decorator)) {
              decorator.addTo(map);
            }
          } else {
            if (map.hasLayer(layer)) {
              map.removeLayer(layer);
            }
            if (decorator && map.hasLayer(decorator)) {
              map.removeLayer(decorator);
            }
          }
        }

        // Update Events
        for (const evt of events) {
          const marker = eventMarkers[evt.id];
          const evtStart = parseDate(evt.start);
          const evtEnd = parseDate(evt.end);
          if (evtStart <= viewEnd && evtEnd >= viewStart) {
            if (!map.hasLayer(marker)) {
              marker.addTo(map);
            }
          } else if (map.hasLayer(marker)) {
            map.removeLayer(marker);
          }
        }
      }

      timeline.on('changed', () => {
          updateIndicator();
          updateMapLayers();
      });

      // Initial updates after everything is set up
      // Use a small timeout to ensure DOM and libraries are fully ready
      setTimeout(() => {
        updateIndicator();
        updateMapLayers();
        if (timelineItems.length > 0) { // If there are items, fit timeline to them
            timeline.fit();
            const firstEvent = events.find(e => e.id === timelineItems.getIds()[0]);
            if (firstEvent && firstEvent.latlng) {
                 map.setView(firstEvent.latlng, 5); // Center map on the first event initially
            }
        } else { // Fallback if no items
            timeline.setWindow(timelineMin, timelineMax);
        }
        // Then re-run updates based on the new window
        updateIndicator();
        updateMapLayers();
      }, 100);

    // --- END OF main.js ---
  </script>
</body>
</html>
